<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>Capture Handle - Bootstrapping Collaboration when Screensharing</title>
    <script class="remove" src="capture-handle.js" type="text/javascript"></script>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  </head>
  <body>
    <section id="abstract">
      <h2>Abstract</h2>
      <p>
        This document proposes a mechanism by which an application <var>APP</var> can opt-in to
        exposing certain information with another application <var>CAPTR</var>, if
        <var>CAPTR</var> is screen-capturing the tab in which <var>APP</var> is running.
      </p>
    </section>
    <section id="conformance"></section>
    <section>
      <h2>Problem Description</h2>
      <section id="genric-problem-desc">
        <h3>Generic Problem Description</h3>
        <p>
          Consider a web-application, running in one tab, which we’ll name "<var>main_app</var>."
          Assume <var>main_app</var> calls
          <a data-cite="SCREEN-CAPTURE#dom-mediadevices-getdisplaymedia">getDisplayMedia</a>
          and the user chooses to share another tab, where an application is running which we’ll
          call "<var>captured_app</var>."
        </p>
        <p>Note that:</p>
        <ol>
          <li><var>main_app</var> does not know what it is capturing.</li>
          <li>
            <var>captured_app</var> does not know that it is being captured; let alone by whom.
          </li>
        </ol>
        <p>
          Both these traits are desirable for the general case, but there exist legitimate use cases
          where the browser would want to allow applications to opt-in to bridging that gap and
          enable a connection.
        </p>
        <p>
          We wish to enable the legitimate use cases while keeping the general case as it was
          before.
        </p>
      </section>
      <section id="use-case-1">
        <h3>Use-case #1: Cross-App Communications</h3>
        <p>
          Consider two applications that wish to cooperate, for example a VC app and a presentation
          app. Assume the user is in a VC session. The user starts sharing a presentation. Both
          applications are interested in letting the VC app discover that it is capturing a slides
          session, which application, and even which session, so that the VC application will be
          able to expose controls to the user for flipping through slides. When the user clicks
          those controls, the VC app will be able to send messages to the presentation app (either
          through a service worker or through a shared back-end infrastructure). These messages will
          instruct the presentation app to flip through slides, enter/leave presentation-mode, etc.
        </p>
      </section>
      <section id="use-case-2">
        <h3>Use-case #2: Analytics</h3>
        <p>
          Capturing applications often wish to gather statistics over what applications their users
          tend to capture. For example, VC applications would like to know how often their users
          share presentation applications from specific providers, Wikipedia, CNN, etc. Gathering
          such information can be used to improve service for the users by introducing new
          collaborations, such as the one described above.
        </p>
      </section>
      <section id="use-case-3">
        <h3>Use-case #3: Detecting Unintended Captures</h3>
        <p>
          Users sometimes choose to share the wrong tab. Sometimes they switch to sharing the wrong
          tab by clicking the share-this-tab-insead button by mistake. A benevolent application
          could try to protect the user by presenting an in-app dialog for re-confirmation, if they
          believe that the user may have made a mistake.
        </p>
      </section>
      <section id="use-case-4">
        <h3>Use-case #4: Avoiding "Hall of Mirrors"</h3>
        <p>
          This use-case is a sub-case of #3, but deserves its own section due to its importance. The
          "Hall of Mirrors" effect occurs when users choose to share the tab in which the VC call
          takes place. When detecting self-capture, a VC application can avoid displaying the
          captured stream back to the user, thereby avoiding the dreaded effect.
        </p>
      </section>
    </section>
    <section id="capture-handle-mechanism">
      <h2>The Capture-Handle Mechanism</h2>
      <p>
        The capture-handle mechanism consists of two main parts - one on the captured side, one on
        the capturing side.
      </p>
      <ul>
        <li>
          <a href="#captured-side">Captured applications</a> opt-in to exposing information by
          calling {{MediaDevices/setCaptureHandleConfig}}.
        </li>
        <li>
          <a href="#capturing-side">Capturing applications</a> read this information as
          {{CaptureHandle}}.
        </li>
      </ul>
    </section>
    <section id="captured-side">
      <h2>Captured-Side</h2>
      <p>
        Applications are allowed to expose information to capturing applications. They would
        typically do so before knowing if they even are captured. The mechanism used is calling
        {{MediaDevices/setCaptureHandleConfig}} with an appropriate {{CaptureHandleConfig}}.
      </p>
      <section id="capture-handle-config">
        <h3><dfn>CaptureHandleConfig</dfn></h3>
        <p>
          The CaptureHandleConfig dictionary is used to instruct the user agent what information the
          captured application intends to expose, and to which applications it is willing to expose
          said information.
        </p>
        <pre class="idl">
          dictionary CaptureHandleConfig {
            boolean exposeOrigin = false;
            DOMString handle = "";
            sequence&lt;DOMString&gt; permittedOrigins = [];
          };          
        </pre>
        <dl data-link-for="CaptureHandleConfig" data-dfn-for="CaptureHandleConfig">
          <dt>
            <dfn>exposeOrigin</dfn>
          </dt>
          <dd>
            <p>
              If <cod>true</cod>, the user agent MUST expose the captured application's origin
              through the {{CaptureHandle/origin}} field of {{CaptureHandle}}. If
              <code>false</code>, the user agent MUST NOT expose the captured application's origin.
            </p>
          </dd>
          <dt>
            <dfn>handle</dfn>
          </dt>
          <dd>
            <p>The user agent MUST expose this value as {{CaptureHandle/handle}}.</p>
            <p>
              Note: Values to this field are limited to 1024 16-bit characters. This limitation is
              specified further in {{MediaDevices/setCaptureHandleConfig}}.
            </p>
          </dd>
          <dt>
            <dfn>permittedOrigins</dfn>
          </dt>
          <dd>
            <p>Legal values of this field include:</p>
            <ul>
              <li>The empty list.</li>
              <li>A list with the single item <code>"*"</code></li>
              <li>Lists consisting of valid origins.</li>
            </ul>
            <p>
              If {{CaptureHandleConfig/permittedOrigins}} consists of the single item
              <code>"*"</code>, then the {{CaptureHandle}} is <dfn>observable</dfn> by all
              capturers. Otherwise, {{CaptureHandle}} is [=observable=] only to capturers whose
              origin is lists in {{CaptureHandleConfig/permittedOrigins}}.
            </p>
          </dd>
        </dl>
      </section>
      <section id="set-capture-handle-config">
        <h3>MediaDevices.setCaptureHandleConfig</h3>
        <p>
          {{MediaDevices}} is extended with a method - {{MediaDevices/setCaptureHandleConfig}} -
          which accepts a {{CaptureHandleConfig}} object. By calling this method, an application
          informs the user agent which information it permits capturing applications to observe.
        </p>
        <pre class="idl">
          partial interface MediaDevices {
            undefined setCaptureHandleConfig(optional CaptureHandleConfig config = {});
          };
        </pre>
        <dl data-link-for="MediaDevices" data-dfn-for="MediaDevices" class="methods">
          <dt>
            <dfn>setCaptureHandleConfig</dfn>
          </dt>
          <dd>
            <p>The user agent MUST run the following validations:</p>
            <ul>
              <li>
                If {{CaptureHandleConfig/handle}} is set to an invalid value, the user agent MUST
                reject by raising {{TypeError}}.
              </li>
              <li>
                If {{CaptureHandleConfig/permittedOrigins}} is set to an invalid value, the user
                agent MUST reject by raising {{NotSupportedError}}.
              </li>
              <li>
                If the call to {{MediaDevices/setCaptureHandleConfig()}} is not from the top-level
                document, the user agent MUST reject by raising {{InvalidStateError}}.
              </li>
            </ul>
            <p>
              If all validations passed, the user agent MUST accept the new config. The user agent
              MUST forget any previous call to {{MediaDevices/setCaptureHandleConfig}}; from now on,
              the application's {{CaptureHandleConfig}} is <var>config</var>.
            </p>
            <p>
              The [=observable=] {{CaptureHandle}} is re-evaluated for all capturing applications.
            </p>
            <ol>
              <li>
                For every capturing application for which the new [=observable=] {{CaptureHandle}}
                is different than prior to the call to {{MediaDevices/setCaptureHandleConfig}}, an
                event of type {{CaptureHandleChangeEvent}} must be fired with
                {{CaptureHandleChangeEvent/captureHandle}} set to the new [=observable=]
                {{CaptureHandle}}.
              </li>
              <li>
                The user agent MUST report the new [=observable=] {{CaptureHandle}} whenever
                producing a new {{MediaTrackSettings}} object.
              </li>
            </ol>
          </dd>
        </dl>
      </section>
    </section>
    <section id="capturing-side">
      <h2>Capturing-Side</h2>
      <p>
        Capturing applications who are permitted to [=observable|observe=] a track's
        {{CaptureHandle}} have two ways of reading it.
      </p>
      <ol>
        <li>Reading the current value returned by {{MediaStreamTrack/getSettings()}}.</li>
        <li>Registering an {{EventListener}} at {{MediaStreamTrack/oncapturehandlechange}}.</li>
      </ol>
      <section id="capture-handle">
        <h3><dfn>CaptureHandle</dfn></h3>
        <p>
          The user agent exposes information about the captured application to the capturing
          application through the {{CaptureHandle}} dictionary. Note that a {{CaptureHandle}} object
          MUST NOT be given to a capturing application that is not permited to
          [=observable|observe=] it.
        </p>
        <pre class="idl">
          dictionary CaptureHandle {
            DOMString origin;
            DOMString handle;
          };
        </pre>
        <dl data-link-for="CaptureHandle" data-dfn-for="CaptureHandle">
          <dt>
            <dfn>origin</dfn>
          </dt>
          <dd>
            <p>
              If the captured application opted-in to exposing its origin (by setting
              {{CaptureHandleConfig/exposeOrigin}} to true), then the user agent MUST set
              {{CaptureHandle/origin}} to the origin of the captured application. Otherwise,
              {{CaptureHandle/origin}} is not set.
            </p>
          </dd>
          <dt>
            <dfn>handle</dfn>
          </dt>
          <dd>
            <p>
              The user agent MUST set this field to the value which the captured application set in
              {{CaptureHandleConfig/handle}}.
            </p>
          </dd>
        </dl>
      </section>
      <section id="capture-handle-via-getsettings">
        <h3>MediaTrackSettings.captureHandle</h3>
        <p>
          {{MediaTrackSettings}} is extended so that calling {{MediaStreamTrack/getSettings()}} on
          tracks derived of screen-capture can now return an extended dictionary that also contains
          a {{MediaTrackSettings/captureHandle}} entry.
        </p>
        <pre class="idl">
          partial dictionary MediaTrackSettings {
            CaptureHandle captureHandle;
          };
        </pre>
        <dl data-link-for="MediaTrackSettings" data-dfn-for="MediaTrackSettings">
          <dt>
            <dfn>captureHandle</dfn>
          </dt>
          <dd>
            <p>
              {{MediaTrackSettings}} objects are produced in reponse to invocations of
              {{MediaStreamTrack/getSettings()}}.
            </p>
            <p>
              If the track in question is not the result of a capture of a display surface, then the
              user agent MUST NOT set a {{MediaTrackSettings/captureHandle}}.
            </p>
            <p>
              If the captured application did not set a {{CaptureHandleConfig}}, or set it and then
              unset it, then the user agent MUST leave {{MediaTrackSettings/captureHandle}} unset.
            </p>
            <p>
              The user agent MUST compare the origin of the capturing document to those which the
              captured application listed in {{CaptureHandleConfig/permittedOrigins}}. If the
              capturing origin is not permitted to [=observable|observe=] the {{CaptureHandle}},
              then the user agent MUST leave {{MediaTrackSettings/captureHandle}} unset.
            </p>
            <p>
              If all previous validations passed, then the user agent MUST set
              {{MediaTrackSettings/captureHandle}} to a {{CaptureHandle}} with the value which are
              correct at the moment the {{MediaTrackSettings}} object is produced.
            </p>
          </dd>
        </dl>
      </section>
      <section id="events">
        <h3>On-Change Event</h3>
        <section id="capture-handle-change-event">
          <h4><dfn>CaptureHandleChangeEvent</dfn></h4>
          <p>
            Whenever the [=observable=] {{CaptureHandle}} for a given capturing application changes,
            the user agent fires an event of type CaptureHandleChangeEvent. This can happen in the
            following cases:
          </p>
          <ol>
            <li>
              The captured application call {{MediaDevices/setCaptureHandleConfig()}} with a new
              {{CaptureHandleConfig}}. (Note that the new {{CaptureHandleConfig}} might or might not
              cause the [=observable=] {{CaptureHandle}} to change, e.g. if changing
              {{CaptureHandleConfig/permittedOrigins}}.)
            </li>
            <li>The captured application's top-level document is navigated cross-document.</li>
            <li>The user agent switches the track to follow a new application.</li>
          </ol>
          <pre class="idl">
            [Exposed=Window]
            interface CaptureHandleChangeEvent : Event {
              constructor(CaptureHandleChangeEventInit init);
              [SameObject] CaptureHandle captureHandle();
            };
          </pre>
          <dl data-link-for="CaptureHandleChangeEvent" data-dfn-for="CaptureHandleChangeEvent">
            <dt>
              <dfn>captureHandle</dfn>
            </dt>
            <dd>
              <p>
                The track's {{CaptureHandle}} at the time the event was fired, as [=observable=] by
                the capturing application. If not [=observable=] by the capturing application, all
                of {{CaptureHandle}}'s fields will be set to their default value - the empty
                {{DOMString}}.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h4><dfn>CaptureHandleChangeEventInit</dfn></h4>
          <pre class="idl">
            dictionary CaptureHandleChangeEventInit : EventInit {
              CaptureHandle captureHandle;
            };
          </pre>
          <dl
            data-link-for="CaptureHandleChangeEventInit"
            data-dfn-for="CaptureHandleChangeEventInit"
          >
            <dt>
              <dfn>captureHandle</dfn>
            </dt>
            <dd>
              <p>The track's {{CaptureHandle}} at the time the event was fired.</p>
            </dd>
          </dl>
        </section>
        <section id="oncapturehandlechange">
          <h4><dfn>oncapturehandlechange</dfn></h4>
          <p>
            {{MediaStreamTrack}} is extended with an {{EventListener}} called
            {{oncapturehandlechange}}.
          </p>
          <pre class="idl">
            partial interface MediaStreamTrack {
              attribute EventHandler oncapturehandlechange;
            };
          </pre>
          <dl data-link-for="MediaStreamTrack" data-dfn-for="MediaStreamTrack">
            <dt>
              <dfn>oncapturehandlechange</dfn>
            </dt>
            <dd>
              <p>{{EventHandler}} for events of type {{CaptureHandleChangeEvent}}.</p>
            </dd>
          </dl>
        </section>
      </section>
    </section>
  </body>
</html>
